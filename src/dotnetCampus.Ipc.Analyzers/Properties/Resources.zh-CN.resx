<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="IPC000" xml:space="preserve">
    <value>IPC 未知错误</value>
  </data>
  <data name="IPC000_Message" xml:space="preserve">
    <value>生成 IPC 代理和对接代码时遇到未知错误：{0}</value>
  </data>
  <data name="IPC001" xml:space="preserve">
    <value>IPC 已知编译错误</value>
  </data>
  <data name="IPC001_Message" xml:space="preserve">
    <value>生成代码时出现已知错误。本生成器不会报告此错误，因为后续编译器会准确报告之。</value>
  </data>
  <data name="IPC002" xml:space="preserve">
    <value>IPC 已知诊断错误</value>
  </data>
  <data name="IPC002_Message" xml:space="preserve">
    <value>生成代码时出现已知错误。本生成器不会报告此错误，因为分析器会准确报告之。</value>
  </data>
  <data name="IPC101" xml:space="preserve">
    <value>IPC 超时时间不可设为负数</value>
  </data>
  <data name="IPC101_Message" xml:space="preserve">
    <value>IPC 超时时间不可设为负数，但这里被设为 {0} 毫秒。</value>
  </data>
  <data name="IPC102" xml:space="preserve">
    <value>超时时间为零</value>
  </data>
  <data name="IPC102_Message" xml:space="preserve">
    <value>0 毫秒的超时时间相当于不设置超时，因此不需要设置此属性。</value>
  </data>
  <data name="IPC131" xml:space="preserve">
    <value>显式允许或忽略 IPC 异常</value>
  </data>
  <data name="IPC131_Fix1" xml:space="preserve">
    <value>忽略 IPC 连接和超时异常</value>
  </data>
  <data name="IPC131_Fix2" xml:space="preserve">
    <value>允许抛出 IPC 连接和超时异常</value>
  </data>
  <data name="IPC131_Message" xml:space="preserve">
    <value>建议显式设置 IgnoresIpcException 以明确处理这里可能出现的 IPC 连接和超时异常。</value>
  </data>
  <data name="IPC160" xml:space="preserve">
    <value>IPC 契约类型必须是接口</value>
  </data>
  <data name="IPC160_Message" xml:space="preserve">
    <value>IPC 契约类型必须是接口，但 {0} 不是。</value>
  </data>
  <data name="IPC161" xml:space="preserve">
    <value>IPC 契约类型与实现的接口不匹配</value>
  </data>
  <data name="IPC161_Fix1" xml:space="preserve">
    <value>修改契约类型为 {0}</value>
  </data>
  <data name="IPC161_Fix2" xml:space="preserve">
    <value>使 {0} 实现 {1} 接口</value>
  </data>
  <data name="IPC161_Message" xml:space="preserve">
    <value>IpcShape 标记的契约类型是 {1}，但是 {0} 却并没有实现这个接口。</value>
  </data>
  <data name="IPC162" xml:space="preserve">
    <value>显式标记所有 IPC 成员</value>
  </data>
  <data name="IPC162_Message" xml:space="preserve">
    <value>IPC 代理壳应显式标记所有成员的 IPC 行为，因为其无法继承契约接口的代理配置。</value>
  </data>
  <data name="IPC200" xml:space="preserve">
    <value>IPC 成员仅支持属性、方法和事件</value>
  </data>
  <data name="IPC200_Message" xml:space="preserve">
    <value>不支持的 IPC 成员 {0}。IPC 成员仅支持属性、方法和事件，不支持其他类型。</value>
  </data>
  <data name="IPC201" xml:space="preserve">
    <value>空的 IPC 特性没有任何用途</value>
  </data>
  <data name="IPC201_Fix" xml:space="preserve">
    <value>删除 {0}</value>
  </data>
  <data name="IPC201_Message" xml:space="preserve">
    <value>空的 {0} 没有任何用途，因此完全可以将其删除。</value>
  </data>
  <data name="IPC202" xml:space="preserve">
    <value>标记 IPC 成员</value>
  </data>
  <data name="IPC202_Message" xml:space="preserve">
    <value>建议为 IPC 代理壳的 {0} 成员配置代理行为。</value>
  </data>
  <data name="IPC240" xml:space="preserve">
    <value>不建议使用 IPC 属性</value>
  </data>
  <data name="IPC240_Message" xml:space="preserve">
    <value>不建议在 IPC 类型中使用属性。应改用异步方法，以避免同步访问属性可能引发的卡顿和死锁风险。</value>
  </data>
  <data name="IPC241" xml:space="preserve">
    <value>IPC 类型不支持只写属性</value>
  </data>
  <data name="IPC241_Message" xml:space="preserve">
    <value>不支持只写属性 {0}。IPC 类型只支持读写属性或只读属性。</value>
  </data>
  <data name="IPC242" xml:space="preserve">
    <value>IPC 默认值不起作用</value>
  </data>
  <data name="IPC242_Fix1" xml:space="preserve">
    <value>去掉此成员的 IPC 默认值</value>
  </data>
  <data name="IPC242_Fix2" xml:space="preserve">
    <value>忽略此成员抛出的 IPC 连接和超时异常</value>
  </data>
  <data name="IPC242_Message" xml:space="preserve">
    <value>不需要设置默认值。IPC 默认值仅在忽略了 IPC 连接和超时异常的情况下才会生效。</value>
  </data>
  <data name="IPC243" xml:space="preserve">
    <value>不需要设置 IsReadonly 属性</value>
  </data>
  <data name="IPC243_Message" xml:space="preserve">
    <value>不需要设置 IsReadonly 属性为 false，因为默认如此。</value>
  </data>
  <data name="IPC244" xml:space="preserve">
    <value>默认值类型与属性类型不匹配</value>
  </data>
  <data name="IPC244_Message" xml:space="preserve">
    <value>IPC 默认值 {0} 与 {1} 属性的类型不匹配。</value>
  </data>
  <data name="IPC245" xml:space="preserve">
    <value>字符串将被编译为代码片段</value>
  </data>
  <data name="IPC245_Message" xml:space="preserve">
    <value>试图将 object 类型的默认值设置为代码片段 {0}。请注意，这里的字符串将被编译为代码片段，如需使用字符串，请修改为“@"""{0}"""”。</value>
  </data>
  <data name="IPC246" xml:space="preserve">
    <value>字符串将被编译为代码片段</value>
  </data>
  <data name="IPC246_Message" xml:space="preserve">
    <value>试图将 {1} 类型的默认值设置为代码片段 {0}。请注意，这里的字符串将被编译为代码片段。</value>
  </data>
  <data name="IPC247" xml:space="preserve">
    <value>字符串编译的代码片段无法被解析</value>
  </data>
  <data name="IPC247_Message" xml:space="preserve">
    <value>字符串中的代码片段 {0} 在当前上下文下无法被解析。</value>
  </data>
  <data name="IPC260" xml:space="preserve">
    <value>不建议使用 IPC 同步方法</value>
  </data>
  <data name="IPC260_Message" xml:space="preserve">
    <value>不建议在 IPC 类型中使用同步。应改用异步方法，以避免同步调用可能引发的卡顿和死锁风险。</value>
  </data>
  <data name="IPC261" xml:space="preserve">
    <value>IPC 默认值不起作用</value>
  </data>
  <data name="IPC261_Fix1" xml:space="preserve">
    <value>去掉此成员的 IPC 默认值</value>
  </data>
  <data name="IPC261_Fix2" xml:space="preserve">
    <value>忽略此成员抛出的 IPC 连接和超时异常</value>
  </data>
  <data name="IPC261_Message" xml:space="preserve">
    <value>不需要设置默认值。IPC 默认值仅在忽略了 IPC 连接和超时异常的情况下才会生效。</value>
  </data>
  <data name="IPC262" xml:space="preserve">
    <value>推荐设置 WaitsVoid 属性</value>
  </data>
  <data name="IPC262_Message" xml:space="preserve">
    <value>在 IPC 访问中难以得知 void 方法调用时是否会等待其返回。虽然默认是不等待，但仍建议显式设置 WaitsVoid 属性以增强此代码的可读性。</value>
  </data>
  <data name="IPC263" xml:space="preserve">
    <value>WaitsVoid 不起作用</value>
  </data>
  <data name="IPC263_Message" xml:space="preserve">
    <value>方法 {0} 有返回值，因此 WaitsVoid 对其不起作用。</value>
  </data>
  <data name="IPC264" xml:space="preserve">
    <value>默认值类型与方法返回值类型不匹配</value>
  </data>
  <data name="IPC264_Message" xml:space="preserve">
    <value>IPC 默认值 {0} 与 {1} 方法的返回值类型不匹配。</value>
  </data>
  <data name="IPC265" xml:space="preserve">
    <value>void 方法的 IPC 默认值不起作用</value>
  </data>
  <data name="IPC265_Message" xml:space="preserve">
    <value>方法 {0} 没有返回值，因此无需设置其 IPC 默认值。</value>
  </data>
  <data name="IPC266" xml:space="preserve">
    <value>异步方法 {0} 没有返回值，因此无需设置其 IPC 默认值。</value>
  </data>
  <data name="IPC266_Message" xml:space="preserve">
    <value>Task 返回值方法的 IPC 默认值不起作用</value>
  </data>
  <data name="IPC267" xml:space="preserve">
    <value>字符串将被编译为代码片段</value>
  </data>
  <data name="IPC267_Message" xml:space="preserve">
    <value>试图将 object 类型的默认值设置为代码片段 {0}。请注意，这里的字符串将被编译为代码片段，如需使用字符串，请修改为“@"""{0}"""”。</value>
  </data>
  <data name="IPC268" xml:space="preserve">
    <value>字符串将被编译为代码片段</value>
  </data>
  <data name="IPC268_Message" xml:space="preserve">
    <value>试图将 {1} 类型的默认值设置为代码片段 {0}。请注意，这里的字符串将被编译为代码片段。</value>
  </data>
  <data name="IPC269" xml:space="preserve">
    <value>字符串编译的代码片段无法被解析</value>
  </data>
  <data name="IPC269_Message" xml:space="preserve">
    <value>字符串中的代码片段 {0} 在当前上下文下无法被解析。</value>
  </data>
  <data name="IPC301" xml:space="preserve">
    <value>通过 IPC 配置项配置 IPC 代理行为</value>
  </data>
  <data name="IPC301_Message" xml:space="preserve">
    <value>通过 IPC 配置项配置 IPC 代理行为。</value>
  </data>
  <data name="IPC302" xml:space="preserve">
    <value>通过 IPC 代理壳配置代理行为</value>
  </data>
  <data name="IPC302_Fix1" xml:space="preserve">
    <value>为 {0} 生成 IPC 代理壳</value>
  </data>
  <data name="IPC302_Fix2" xml:space="preserve">
    <value>在新文件中为 {0} 生成 IPC 代理壳</value>
  </data>
  <data name="IPC302_Message" xml:space="preserve">
    <value>通过 IPC 代理壳配置代理行为。</value>
  </data>
  <data name="IPC303" xml:space="preserve">
    <value>传入 IPC 配置项来配置 IPC 代理行为</value>
  </data>
  <data name="IPC303_Message" xml:space="preserve">
    <value>IPC 契约类型上没有指定代理行为，可以通过在这里传入 IPC 配置项来配置。</value>
  </data>
  <data name="IPC304" xml:space="preserve">
    <value>无需传入 IPC 配置项</value>
  </data>
  <data name="IPC304_Message" xml:space="preserve">
    <value>IPC 契约类型上指定的代理行为已经覆盖了这里的所有 IPC 配置项，因此这里无需额外传入。</value>
  </data>
  <data name="IPC305" xml:space="preserve">
    <value>建议显式设置 IgnoresIpcException</value>
  </data>
  <data name="IPC305_Message" xml:space="preserve">
    <value>建议显式设置 IgnoresIpcException 以明确处理这里可能出现的 IPC 连接和超时异常。</value>
  </data>
  <data name="IPC306" xml:space="preserve">
    <value>无需设置 IgnoresIpcException</value>
  </data>
  <data name="IPC306_Message" xml:space="preserve">
    <value>无需设置 IgnoresIpcException，因为 IPC 契约类型上已经设置了此属性。</value>
  </data>
  <data name="IPC307" xml:space="preserve">
    <value>显式设置 Timeout</value>
  </data>
  <data name="IPC307_Message" xml:space="preserve">
    <value>显式设置 Timeout。</value>
  </data>
  <data name="IPC308" xml:space="preserve">
    <value>无需设置 Timeout</value>
  </data>
  <data name="IPC308_Message" xml:space="preserve">
    <value>无需设置 Timeout，因为 IPC 契约类型上已经设置了此属性。</value>
  </data>
  <data name="IPC309" xml:space="preserve">
    <value>不是有效的 IPC 代理壳</value>
  </data>
  <data name="IPC309_Message" xml:space="preserve">
    <value>指定的 IpcShape 参数 {0} 不是有效的 IPC 代理壳。</value>
  </data>
  <data name="IPC310" xml:space="preserve">
    <value>契约接口与代理壳不匹配</value>
  </data>
  <data name="IPC310_Message" xml:space="preserve">
    <value>指定的 IpcShape 参数 {0} 不是针对 {1} 的 IPC 代理壳。</value>
  </data>
</root>